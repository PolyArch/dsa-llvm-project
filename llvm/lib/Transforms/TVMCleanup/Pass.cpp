#include <cstdlib>
#include <sstream>
#include <fstream>
#include <queue>
#include <map>

#include "llvm/ADT/BreadthFirstIterator.h"
#include "llvm/Analysis/LoopAccessAnalysis.h"
#include "llvm/Analysis/LoopAnalysisManager.h"
#include "llvm/Analysis/OptimizationRemarkEmitter.h"
#include "llvm/Support/Format.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/InlineAsm.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Dominators.h"
#include "llvm/Transforms/Utils/LoopUtils.h"
#include "llvm/Transforms/Utils/UnrollLoop.h"

#include "dsa/debug.h"

using namespace llvm;

#define DEBUG_TYPE "tvm-cleanup"

struct TVMCleanup : public ModulePass {

  TVMCleanup() : ModulePass(ID) {}

  // {
  bool runOnModule(Module &M) override;
  void getAnalysisUsage(AnalysisUsage &AU) const override;
  // }


  static char ID;
};

bool TVMCleanup::runOnModule(Module &M) {
  std::vector<std::string> ToRemove;
  for (auto &F : M.getFunctionList()) {
    if (F.getName().endswith("_compute_")) {
      auto Name = F.getName();
      ToRemove.emplace_back(Name.substr(0, Name.size() - std::string("_compute_").size()).str());
      llvm::errs() << "Will remove " << ToRemove.back() << "\n";
    }
  }
  for (auto &Elem : ToRemove) {
    auto F = M.getFunction(Elem);
    CHECK(F) << Elem << " function not found!";
    F->replaceAllUsesWith(UndefValue::get(F->getType()));
    F->eraseFromParent();
    auto FC = M.getFunction(Elem + "_compute_");
    CHECK(FC) << Elem << "_compute_ function not found!";
    FC->setName(Elem);
    FC->setLinkage(GlobalValue::LinkageTypes::ExternalLinkage);
  }

  llvm::PassManagerBuilder PMB;
  PMB.OptLevel = 3;
  PMB.Inliner = nullptr;
  PMB.LoopVectorize = false;
  PMB.SLPVectorize = false;
  PMB.DisableUnrollLoops = true;
  llvm::legacy::FunctionPassManager fpass(&M);
  llvm::legacy::PassManager mpass;
  PMB.populateFunctionPassManager(fpass);
  PMB.populateModulePassManager(mpass);

  for (auto &F : M.getFunctionList()) {
    fpass.run(F);
  }
  fpass.doFinalization();
  mpass.run(M);

  return false;
}

void TVMCleanup::getAnalysisUsage(AnalysisUsage &AU) const {
}

char TVMCleanup::ID = 0;

static RegisterPass<TVMCleanup> X("tvm-cleanup", "Cleanup the boundry enforcement generated by TVM...");
